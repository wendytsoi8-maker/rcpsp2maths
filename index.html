<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>立體圖形（角柱／角錐）學習平台</title>
  <style>
    :root { --bg:#0b1020; --card:#121a33; --text:#eef2ff; --muted:#b7c0ff; --btn:#2a3cff; --danger:#ff3b3b; }
    * { box-sizing: border-box; }
    body {
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans TC","PingFang TC","Microsoft JhengHei",sans-serif;
      background: radial-gradient(1200px 800px at 30% 10%, #1a2457 0%, var(--bg) 60%);
      color: var(--text);
    }
    header { padding: 18px 16px 8px; max-width: 1200px; margin: 0 auto; }
    h1 { margin: 0 0 6px; font-size: 22px; }
    .sub { margin: 0; color: var(--muted); font-size: 14px; line-height: 1.4; }

    .wrap { max-width: 1200px; margin: 0 auto; padding: 12px 16px 24px; display: grid; grid-template-columns: 360px 1fr; gap: 14px; }
    @media (max-width: 980px) { .wrap { grid-template-columns: 1fr; } }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .row { display:flex; gap:10px; align-items:center; margin: 10px 0; flex-wrap: wrap; }
    label { font-size: 14px; color: var(--muted); min-width: 92px; }
    select {
      flex: 1;
      min-width: 180px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(10,14,28,0.65);
      color: var(--text);
      outline: none;
    }
    .btns { display:flex; gap:10px; margin-top: 12px; }
    button {
      flex:1;
      border: none;
      padding: 11px 12px;
      border-radius: 12px;
      background: var(--btn);
      color: white;
      font-weight: 800;
      cursor: pointer;
      transition: transform .06s ease;
    }
    button:active { transform: translateY(1px); }
    button.secondary {
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      color: var(--text);
      font-weight: 800;
    }
    .hint { margin-top: 10px; font-size: 13px; color: var(--muted); line-height: 1.55; }
    .warn { margin-top: 10px; font-size: 13px; color: #ffd1d1; background: rgba(255,59,59,0.12); border: 1px solid rgba(255,59,59,0.25); padding: 10px 12px; border-radius: 12px; display:none; }

    .viewerTop { display:flex; align-items:flex-start; justify-content:space-between; gap: 10px; flex-wrap: wrap; }
    .nameBox { padding: 10px 12px; border-radius: 12px; border:1px solid rgba(255,255,255,0.14); background: rgba(10,14,28,0.55); min-height: 44px; }
    .nameTitle { font-size: 13px; color: var(--muted); margin-bottom: 4px; }
    .shapeName { font-size: 18px; font-weight: 900; letter-spacing: .2px; }

    #canvasWrap { margin-top: 12px; border-radius: 14px; overflow:hidden; border: 1px solid rgba(255,255,255,0.12); background: rgba(0,0,0,0.25); }
    canvas#c { display:block; width: 100%; height: 460px; }

    .facesCard { margin-top: 12px; padding: 12px; border-radius: 14px; border: 1px solid rgba(255,255,255,0.12); background: rgba(10,14,28,0.40); }
    .facesHead { display:flex; align-items:center; justify-content:space-between; gap: 10px; flex-wrap: wrap; }
    .facesTitle { font-size: 14px; color: var(--muted); }
    .facesGrid {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 10px;
    }
    .faceItem {
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(255,255,255,0.06);
    }
    .faceLabel {
      padding: 6px 8px;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.15);
    }
    .faceCanvas { display:block; width:100%; height:auto; background: rgba(0,0,0,0.10); }

    .footerNote { margin-top: 10px; color: var(--muted); font-size: 12px; line-height: 1.5; }
    .kbd { padding: 2px 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>立體圖形學習平台（角柱／角錐）</h1>
    <p class="sub">流程：先選「底的數量（1/2）」→ 再選「側面的數量（3–20）」→ 再選「總共有多少個面」→ 按「確定」顯示名稱、3D 圖，以及所有面的 2D 圖。</p>
  </header>

  <main class="wrap">
    <section class="card">
      <div class="row">
        <label for="baseSel">底的數量</label>
        <!-- ✅ 由 1 排先，再到 2 -->
        <select id="baseSel">
          <option value="1">1</option>
          <option value="2">2</option>
        </select>
      </div>

      <div class="row">
        <label for="sideSel">側面數量</label>
        <select id="sideSel"></select>
      </div>

      <div class="row">
        <label for="totalSel">總面數</label>
        <select id="totalSel"></select>
      </div>

      <div class="btns">
        <button id="okBtn">確定</button>
        <button id="resetBtn" class="secondary">重設</button>
      </div>

      <div id="warnBox" class="warn"></div>

      <div class="hint">
        <b>規則（只涵蓋（三至二十）角柱、（三至二十）角錐）：</b><br/>
        角柱：底=2，側面=n ⇒ 總面 = n + 2<br/>
        角錐：底=1，側面=n ⇒ 總面 = n + 1
      </div>

      <div class="footerNote">
        3D 由 <span class="kbd">Three.js</span> 即時生成；拖曳旋轉、滾輪縮放、右鍵拖曳平移。
      </div>
    </section>

    <section class="card">
      <div class="viewerTop">
        <div class="nameBox" style="flex:1;">
          <div class="nameTitle">立體圖形名稱</div>
          <div id="shapeName" class="shapeName">（尚未選擇）</div>
        </div>
        <div class="nameBox" style="min-width: 260px;">
          <div class="nameTitle">小提示</div>
          <div style="font-size:13px;color:var(--muted);line-height:1.4;">
            拖曳旋轉｜滾輪縮放｜右鍵平移
          </div>
        </div>
      </div>

      <div id="canvasWrap">
        <canvas id="c"></canvas>
      </div>

      <div class="facesCard">
        <div class="facesHead">
          <div class="facesTitle">該立體圖形的所有面（2D 圖）</div>
          <div style="font-size:12px;color:var(--muted);">例：三角柱＝2 個三角形＋3 個四邊形</div>
        </div>
        <div id="facesGrid" class="facesGrid"></div>
      </div>

      <div class="footerNote">
        若顯示空白：請用較新版本瀏覽器，並確保 GitHub Pages 係 <span class="kbd">https</span>。
      </div>
    </section>
  </main>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // ===== UI =====
    const baseSel = document.getElementById("baseSel");
    const sideSel = document.getElementById("sideSel");
    const totalSel = document.getElementById("totalSel");
    const okBtn = document.getElementById("okBtn");
    const resetBtn = document.getElementById("resetBtn");
    const warnBox = document.getElementById("warnBox");
    const shapeNameEl = document.getElementById("shapeName");
    const facesGrid = document.getElementById("facesGrid");

    function showWarn(msg) { warnBox.style.display = "block"; warnBox.textContent = msg; }
    function clearWarn() { warnBox.style.display = "none"; warnBox.textContent = ""; }

    function setOptions(selectEl, values, selected = null) {
      selectEl.innerHTML = "";
      for (const v of values) {
        const opt = document.createElement("option");
        opt.value = String(v);
        opt.textContent = String(v);
        selectEl.appendChild(opt);
      }
      if (selected !== null) selectEl.value = String(selected);
    }

    function initSideOptions() {
      const arr = [];
      for (let i = 3; i <= 20; i++) arr.push(i);
      setOptions(sideSel, arr, 3);
    }

    function initTotalOptions() {
      const arr = [];
      for (let i = 0; i <= 40; i++) arr.push(i);
      setOptions(totalSel, arr, 0);
    }

    function refreshDefaultTotal() {
      const base = Number(baseSel.value);
      const n = Number(sideSel.value);
      const correct = base === 2 ? (n + 2) : (n + 1);
      totalSel.value = String(correct);
    }

    baseSel.addEventListener("change", refreshDefaultTotal);
    sideSel.addEventListener("change", refreshDefaultTotal);

    // ===== 中文數字（0–99）=====
    function numToZh(n) {
      const digits = ["零","一","二","三","四","五","六","七","八","九"];
      if (n < 10) return digits[n];
      if (n === 10) return "十";
      if (n < 20) return "十" + digits[n - 10];
      if (n % 10 === 0) return digits[Math.floor(n / 10)] + "十";
      return digits[Math.floor(n / 10)] + "十" + digits[n % 10];
    }

    // 平面圖形名稱：三角形 / 四邊形 / 五邊形 / … / 二十邊形
    function polygonNameZh(sides) {
      const zh = numToZh(sides);
      if (sides === 3) return "三角形";
      if (sides === 4) return "四邊形";
      return `${zh}邊形`;
    }

    // ===== Three.js Scene =====
    const canvas = document.getElementById("c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1020, 10, 40);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 200);
    camera.position.set(6, 4.5, 8);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(6, 10, 6);
    scene.add(dir);

    const groundGeo = new THREE.PlaneGeometry(50, 50);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x0f1733, roughness: 0.9, metalness: 0.0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -2.2;
    scene.add(ground);

    const grid = new THREE.GridHelper(30, 30, 0x3340aa, 0x1c255c);
    grid.position.y = -2.19;
    grid.material.opacity = 0.25;
    grid.material.transparent = true;
    scene.add(grid);

    let currentGroup = null;

    function clearCurrent() {
      if (!currentGroup) return;
      scene.remove(currentGroup);
      currentGroup.traverse(obj => {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
          else obj.material.dispose();
        }
      });
      currentGroup = null;
    }

    function buildSolid(spec) {
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({
        color: 0x9fb3ff,
        roughness: 0.45,
        metalness: 0.05
      });
      const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.65 });

      let geo;
      const radius = 2.2;
      const height = 4.2;

      if (!spec) {
        geo = new THREE.BoxGeometry(3, 3, 3);
      } else if (spec.kind === "nPrism") {
        geo = new THREE.CylinderGeometry(radius, radius, height, spec.n, 1, false);
      } else if (spec.kind === "nPyramid") {
        geo = new THREE.CylinderGeometry(0, radius, height, spec.n, 1, false);
      } else {
        geo = new THREE.BoxGeometry(3, 3, 3);
      }

      const mesh = new THREE.Mesh(geo, mat);
      group.add(mesh);

      const edges = new THREE.EdgesGeometry(geo, 20);
      const wire = new THREE.LineSegments(edges, lineMat);
      group.add(wire);

      return group;
    }

    function setShape(spec) {
      clearCurrent();
      currentGroup = buildSolid(spec);
      scene.add(currentGroup);
      controls.target.set(0, 0.2, 0);
      controls.update();
    }

    function resize() {
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);

    function animate() {
      resize();
      if (currentGroup) currentGroup.rotation.y += 0.002;
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // ===== 2D 面圖生成 =====
    function clearFaces() { facesGrid.innerHTML = ""; }

    function makeFaceCard(canvasEl, labelText) {
      const wrap = document.createElement("div");
      wrap.className = "faceItem";
      canvasEl.className = "faceCanvas";
      wrap.appendChild(canvasEl);

      const lab = document.createElement("div");
      lab.className = "faceLabel";
      lab.textContent = labelText;
      wrap.appendChild(lab);

      facesGrid.appendChild(wrap);
    }

    function drawPolygonFace(sides, label) {
      const c = document.createElement("canvas");
      const size = 160;
      c.width = size;
      c.height = size;
      const ctx = c.getContext("2d");

      const R = 55;
      const cx = size/2, cy = size/2;

      ctx.clearRect(0,0,size,size);

      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const a = -Math.PI/2 + i * (2*Math.PI/sides);
        const x = cx + R*Math.cos(a);
        const y = cy + R*Math.sin(a);
        if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();

      ctx.fillStyle = "rgba(159,179,255,0.22)";
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(255,255,255,0.85)";
      ctx.stroke();

      makeFaceCard(c, label);
    }

    function drawRectangleFace(label) {
      const c = document.createElement("canvas");
      const w = 160, h = 160;
      c.width = w; c.height = h;
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,w,h);

      const pad = 30;
      ctx.beginPath();
      ctx.rect(pad, 45, w - pad*2, h - 90);
      ctx.closePath();

      ctx.fillStyle = "rgba(159,179,255,0.22)";
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(255,255,255,0.85)";
      ctx.stroke();

      makeFaceCard(c, label);
    }

    function drawTriangleFace(label) {
      const c = document.createElement("canvas");
      const size = 160;
      c.width = size; c.height = size;
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,size,size);

      ctx.beginPath();
      ctx.moveTo(size/2, 28);
      ctx.lineTo(28, size-30);
      ctx.lineTo(size-28, size-30);
      ctx.closePath();

      ctx.fillStyle = "rgba(159,179,255,0.22)";
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(255,255,255,0.85)";
      ctx.stroke();

      makeFaceCard(c, label);
    }

    function renderAllFaces(baseCount, sideCount) {
      clearFaces();

      const baseShapeName = polygonNameZh(sideCount);

      if (baseCount === 2) {
        drawPolygonFace(sideCount, `底面（${baseShapeName}）#1`);
        drawPolygonFace(sideCount, `底面（${baseShapeName}）#2`);
        for (let i = 1; i <= sideCount; i++) {
          drawRectangleFace(`側面（四邊形）#${i}`);
        }
      } else {
        drawPolygonFace(sideCount, `底面（${baseShapeName}）`);
        for (let i = 1; i <= sideCount; i++) {
          drawTriangleFace(`側面（三角形）#${i}`);
        }
      }
    }

    // ===== 名稱（角柱/角錐）=====
    function toChineseNumber(n) {
      const map = {3:"三",4:"四",5:"五",6:"六",7:"七",8:"八",9:"九",10:"十"};
      if (map[n]) return map[n];
      if (n > 10 && n < 20) return "十" + ({1:"一",2:"二",3:"三",4:"四",5:"五",6:"六",7:"七",8:"八",9:"九"}[n-10]);
      if (n === 20) return "二十";
      return String(n);
    }

    function computeResult(baseCount, sideCount, totalFaces) {
      const n = sideCount;
      if (n < 3 || n > 20) return null;

      if (baseCount === 2) {
        const correct = n + 2;
        if (totalFaces !== correct) return null;
        return {
          name: `${toChineseNumber(n)}角柱`,
          spec: { kind: "nPrism", n },
          baseCount, sideCount
        };
      }

      if (baseCount === 1) {
        const correct = n + 1;
        if (totalFaces !== correct) return null;
        return {
          name: `${toChineseNumber(n)}角錐`,
          spec: { kind: "nPyramid", n },
          baseCount, sideCount
        };
      }

      return null;
    }

    // ===== Buttons =====
    okBtn.addEventListener("click", () => {
      clearWarn();

      const baseCount = Number(baseSel.value);
      const sideCount = Number(sideSel.value);
      const totalFaces = Number(totalSel.value);

      const result = computeResult(baseCount, sideCount, totalFaces);

      if (!result) {
        shapeNameEl.textContent = "（你的輸入無法生成立體圖形）";
        showWarn("你的輸入無法生成立體圖形，請按「重設」後再試一次。\n提示：底=2 總面=側面+2；底=1 總面=側面+1。");
        setShape(null);
        clearFaces();
        return;
      }

      shapeNameEl.textContent = result.name;

      setShape(null);
      clearFaces();

      setTimeout(() => setShape(result.spec), 350);
      setTimeout(() => renderAllFaces(result.baseCount, result.sideCount), 700);
    });

    resetBtn.addEventListener("click", () => {
      clearWarn();
      // ✅ 因為現在 1 排先，所以重設預設值也改成 1
      baseSel.value = "1";
      sideSel.value = "3";
      refreshDefaultTotal();
      shapeNameEl.textContent = "（尚未選擇）";
      setShape(null);
      clearFaces();
    });

    // ===== init =====
    initSideOptions();
    initTotalOptions();
    refreshDefaultTotal();
    setShape(null);
    clearFaces();
    animate();
  </script>
</body>
</html>
